PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX powla: <http://purl.org/powla/powla.owl#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX conll: <http://ufal.mff.cuni.cz/conll2009-st/task-description.html#>
PREFIX nif: <http://persistence.uni-leipzig.org/nlp2rdf/ontologies/nif-core#>
PREFIX paula: <https://github.com/korpling/paula-xml#> # annotation properties

# conversion to CoNLL-RDF
# (0) infer powla data structures
# (0.1) infer powla:Relation, powla:Node
INSERT {
  ?x a ?type.
  ?y a powla:Node.
  ?x ?prop ?y.
} WHERE {
  FILTER(?prop in (powla:next,powla:nextTerm,powla:hasParent,powla:hasTarget,powla:hasSource))
  ?rel rdfs:subPropertyOf* ?prop. # poor man's inference ;)
  ?x ?rel ?y.
  VALUES(?x ?type) {
    (powla:next powla:Node)
    (powla:hasParent powla:Node)
    (powla:hasTarget powla:Relation)
    (powla:hasSource powla:Relation)
  }
};

# (0.2) infer powla:next
# (0.2.a) enforce powla:nextTerm
INSERT {
  ?a powla:nextTerm ?b
} WHERE {
  ?a powla:next ?b.
  MINUS { ?a ^powla:hasParent [] }
  MINUS { ?b ^powla:hasParent [] }
  MINUS { ?a powla:next+ ?c. ?c powla:next+ ?b. MINUS { ?c ^powla:hasParent [] }}
};

# (0.2.b) remove other powla:next
DELETE {
  ?a powla:next ?b
} WHERE {
  ?a powla:next ?b.
};

# (0.2.c) overgenerate powla:next
INSERT {
  ?a powla:next ?b
} WHERE {
  ?a powla:hasParent ?parent.
  ?b powla:hasParent ?parent.
  FILTER(?a!=?b)
  ?a (^powla:hasParent)*/powla:nextTerm+/powla:hasParent* ?b.
};

# (0.2.d) prune (this is a bit too restrictive if nodes are shared by multiple trees)
DELETE {
  ?a powla:next ?b.
} WHERE {
  ?a powla:next ?b.
  ?a powla:hasParent ?p.
  ?b powla:hasParent ?p.
  ?a powla:next+ [ powla:hasParent ?p; powla:next+ ?b ]
};

# (a) infer nif:Word, nif:nextWord
INSERT {
  ?v a nif:Word.
  ?w a nif:Word.
  ?v nif:nextWord ?w.
} WHERE {
  ?v (nif:nextWord|powla:nextTerm) ?w
};

# (b) conll:ID and conll:WORD
# (b.1) conll:ID
INSERT {
  ?w conll:ID ?id
} WHERE {
  {
    SELECT ?w (str(COUNT(distinct ?pre)) as ?id)
    WHERE {
      ?w a nif:Word.
      ?pre (nif:nextWord|powla:nextTerm)* ?w.
    } GROUP BY ?w
  }
};

# (b.2) conll:WORD, conll:ID for singletons
INSERT {
  ?w conll:WORD ?string.
  ?w conll:ID ?id.
} WHERE {
  ?w powla:string ?string. MINUS { ?w a nif:Word; conll:WORD [] }
  OPTIONAL {
    ?w conll:ID ?oldid
  }
  BIND(if(bound(?oldid),?oldid,"1") as ?id)
};

# (c) infer powla:Root (to detect markables)
INSERT {
  ?r a powla:Root
} WHERE {
  ?w a nif:Word; powla:hasParent* ?r.
  MINUS { ?r powla:hasParent [] }
};

# (d) use powla:Nonterminal for non-Terms and non-Roots
DELETE {
  ?x a powla:Nonterminal
} WHERE {
  ?x a powla:Nonterminal
};
INSERT {
  ?x a powla:Nonterminal.
} WHERE {
  ?x powla:hasParent [].
  [] powla:hasParent ?x.
};

# (e) infer layer
# (e.1) propagate from root
# (note that this can lead to assign the same node multiple layers)
INSERT {
  ?w powla:hasLayer ?layer
} WHERE {
  ?w powla:hasParent+/powla:hasLayer ?layer.
  MINUS { ?w powla:hasLayer [] }
};

# (e.2)
# there is no layer, create one from the baseURI
INSERT {
  ?w powla:hasLayer ?layer.
  ?layer a powla:Layer.
} WHERE {
  ?w a powla:Node. MINUS { ?w a powla:Node; powla:hasLayer [] }
  BIND(URI(concat(replace(str(?w),"[#/][^#/]*$",""),"/layer")) as ?layer)
};

# (f) classify layer type
# note: these are currently not formally part of POWLA, resurrect?
# (f.1) token layer (note that we do not enforce uniqueness)
INSERT {
  ?layer a powla:TokenLayer.
} WHERE {
  ?layer a powla:Layer.
  MINUS { ?layer a powla:StructLayer }
  MINUS { ?layer a powla:MarkLayer }
  ?w a nif:Word; powla:hasLayer ?layer.
  MINUS {
    ?w powla:hasLayer ?layer.
    MINUS { ?w a nif:Word. }
  }
};

# (f.2) struct layer: labelled dependencies or deep nesting
INSERT {
  ?layer a powla:StructLayer.
} WHERE {
  ?layer a powla:Layer.
  MINUS { ?layer a powla:TokenLayer }
  MINUS { ?layer a powla:MarkLayer }
   { # recursive (deep) structure
    [] powla:hasParent/powla:hasParent+/powla:hasLayer ?layer.
   } UNION
   { ?p powla:hasLayer ?layer.               # or labelled edges
     ?n powla:hasParent ?p; ^powla:hasSource ?rel.
     ?rel powla:hasTarget ?p.
     MINUS {
      ?rel powla:hasTarget/powla:hasLayer ?layer.
      ?rel powla:hasLayer ?tmp.
      FILTER(?tmp!=?layer)
      }
   }
};

# (f.3) mark layer: flat annotations over tokens
INSERT {
  ?layer a powla:MarkLayer
} WHERE {
  ?layer a powla:Layer.
  MINUS { ?layer a powla:TokenLayer }
  MINUS { ?layer a powla:StructLayer }
  [ a nif:Word ] powla:hasParent/powla:hasLayer ?layer.
  # deep nesting excluded because of (f.2)
};

# (f.4) rel layer: relations, no nodes
INSERT {
  ?layer a powla:RelLayer
} WHERE {
  ?layer a powla:Layer.
  MINUS { ?layer a powla:TokenLayer }
  MINUS { ?layer a powla:StructLayer }
  MINUS { ?layer a powla:MarkLayer }
  [a powla:Relation ] powla:hasLayer ?layer.
  MINUS {
    [ a powla:Node ] powla:hasLayer ?layer.
  }
};

# (f.5) other: struct layer
# this is a fallback solutions if no layers were specified, but note that we
# cannot be certain that these actually form valid trees
# in the serialization, we will make them trees without warning
INSERT {
  ?layer a powla:StructLayer
} WHERE {
  ?layer a powla:Layer.
  MINUS { ?layer a powla:TokenLayer }
  MINUS { ?layer a powla:StructLayer }
  MINUS { ?layer a powla:MarkLayer }
  MINUS { ?layer a powla:RelLayer }
  [a powla:Node ] powla:hasLayer ?layer
};

# (g) transform annotations to conll properties
# (g.1) token layer: note that we do not create sentence objects, yet.
DELETE {
  ?w ?prop ?val.
} INSERT {
  ?w a nif:Word.
  ?w ?conll ?val.
} WHERE {
  ?prop rdfs:subPropertyOf* powla:hasAnnotation.
  ?w powla:hasLayer/a powla:TokenLayer.
  ?w ?prop ?val.
  FILTER(isLiteral(?val))
  BIND(URI(concat("http://ufal.mff.cuni.cz/conll2009-st/task-description.html#",
    ucase(replace(str(?prop),".*[#/]([^#/]+)$","$1")))) as ?conll)
};

# (g.2) mark layer: IOBES encoding
DELETE {
  ?p ?prop ?val.
} INSERT {
  ?w ?conll ?iobVal.
} WHERE {
  ?prop rdfs:subPropertyOf* powla:hasAnnotation.
  ?p ?prop ?val.
  FILTER(isLiteral(?val))
  ?p powla:hasLayer/a powla:MarkLayer.
  ?w a nif:Word; powla:hasParent ?p.
  OPTIONAL {
    ?w a nif:Word; powla:hasParent ?p.
    ?pre a nif:Word; powla:hasParent ?p.
    ?pre nif:nextWord+ ?w.
  }
  OPTIONAL {
    ?w a nif:Word; powla:hasParent ?p.
    ?post a nif:Word; powla:hasParent ?p.
    ?w nif:nextWord+ ?post.
  }
  BIND(
    concat(
      if(bound(?pre), if(bound(?post),"I-","E-"),
                      if(bound(?post),"B-","S-")),
      ?val) as ?iobVal)
  BIND(URI(concat("http://ufal.mff.cuni.cz/conll2009-st/task-description.html#",
    ucase(replace(str(?prop),".*[#/]([^#/]+)$","$1")))) as ?conll)
};

# (g.3) struct layer: phrasal encoding
# note that we use URI encoding to encode feature-value pairs
INSERT {
  ?w ?conll ?phrases
} WHERE {
  ?w a nif:Word; powla:hasParent* ?p.
  ?p powla:hasLayer ?l.
  ?l a powla:StructLayer.
  MINUS { [powla:hasLayer ?l ] powla:hasParent+ ?p. ?p powla:hasParent ?l }
  # ?p is the lowest layer element, so we take its annotations

  OPTIONAL {
    SELECT ?root ?l ?p (GROUP_CONCAT(?par; separator=" ") as ?pre)
    WHERE { # we overgenerate and then return the lowest annotation
      ?l a powla:StructLayer.
      ?root powla:hasLayer ?l.
      MINUS { ?root powla:hasLayer ?l; powla:hasParent+/powla:hasLayer ?l }
      ?root (^powla:hasParent)* ?p.

      # only opening elements
      # CAUTION: this may mess up top-down order!
      MINUS {
        ?pre powla:hasParent ?par; powla:hasLayer ?l.
        ?par powla:hasLayer ?l.
        ?pre powla:next+ ?p; powla:hasLayer ?l }

      ?p powla:hasLayer ?l.
      OPTIONAL {
        SELECT ?p (GROUP_CONCAT(?anno; separator="|") as ?annos)
        WHERE {
          ?rel rdfs:subPropertyOf* powla:hasAnnotation.
          ?p ?rel ?val.
          FILTER(isLiteral(?val))
          BIND(concat(
            replace(str(?rel),".*[#/]([^#/]+)$","$1"),
            "=",
            encode_for_uri(?val)) as ?anno)
        } GROUP BY ?p
      }
      OPTIONAL {
        # note: no edge labels of annotations if annotated to elements from another layer
        # e.g., if directly annotated on tokens
        SELECT ?p (GROUP_CONCAT(?anno; separator="|") as ?rels)
        WHERE {
          ?p powla:hasParent ?parent.
          ?rel powla:hasSource ?p; powla:hasTarget ?parent. # check directions!
          ?relAnno rdfs:subPropertyOf* powla:hasAnnotation.
          ?rel ?relAnno ?val.
          FILTER(isliteral(?val))
          BIND(concat(
            replace(str(?relAnno),".*[#/]([^#/]+)$","$1"),
            "=",
            encode_for_uri(?val)) as ?anno)
        } GROUP BY ?p
      }

      BIND(if(bound(?annos), if(bound(?rels), concat("(",?rels,"|",?annos),
                                              concat("(",?annos)),
                             if(bound(?rels), concat("(",?rels),
                                              "(")) as ?par)
    } GROUP BY ?root ?l ?p
  }

  OPTIONAL {
    SELECT ?l ?p (GROUP_CONCAT(?par;separator="") as ?post)
    WHERE {
      ?l a powla:StructLayer.
      ?p powla:hasLayer ?l.
      MINUS { ?p powla:next/powla:hasLayer ?l }
      BIND(")" as ?par)
    } GROUP BY ?l ?p
  }

  BIND( concat(
          if(bound(?pre), concat(?pre," "), ""),
          "*",
          if(bound(?post), concat(" ",?post),"")) as ?phrases)
};

# (g.4) relations, CoNLL-U DEPS-style encoding (4:nsubj|11:nsubj)
#       note that we create these as datatype properties
DELETE {
  ?rel ?anno ?val
} INSERT {
  ?w ?conll ?dep
} WHERE {
  ?anno rdfs:subPropertyOf* powla:hasAnnotation.
  ?rel a powla:Relation; ?anno ?val; powla:hasSource ?w; powla:hasTarget ?tgt.
  MINUS { ?w powla:hasParent ?tgt }
  ?tgt conll:ID ?head.
  FILTER(isliteral(?val))
  BIND(concat(str(?head),":",?val) as ?dep)
  BIND(URI(concat("http://ufal.mff.cuni.cz/conll2009-st/task-description.html#",
    ucase(replace(str(?anno),".*[#/]([^#/]+)$","$1")))) as ?conll)
};

# (h) infer sentences after a struct
# ?

# (i) deduplicate CoNLL properties
DELETE {
  ?w ?conll ?v
} INSERT {
  ?w ?conll ?agg
} WHERE {
  ?w a nif:Word; ?conll ?v
  FILTER(strstarts(str(?conll),"http://ufal.mff.cuni.cz/conll2009-st/task-description.html#"))
  { SELECT ?w ?conll (GROUP_CONCAT(distinct(?val);separator="|") as ?agg)
    WHERE {
      ?w a nif:Word; ?conll ?val.
      FILTER(strstarts(str(?conll),"http://ufal.mff.cuni.cz/conll2009-st/task-description.html#"))
      FILTER(isLiteral(?val))
    } GROUP BY ?w ?conll
  }
};

# (k) create one nif:Sentence for every continuous sequence of words
#     (should be the entire text)
#     (NB: sentence sequence can be extrapolated from URIs of first words)
#     ? split after every root struct
#     note: this will fail if a powla property powla:head or the like does exist
DELETE {
  ?a ?b ?olds.
  ?olds ?c ?d.
} INSERT {
  ?w conll:HEAD ?s.
  ?s a nif:Sentence.
} WHERE {
  ?w a nif:Word.
  OPTIONAL { ?w conll:HEAD ?olds. ?olds a nif:Sentence.
    OPTIONAL { ?a ?b ?olds }
    OPTIONAL { ?olds ?c ?d }
   }
  MINUS { ?w conll:HEAD [] }
  ?first nif:nextWord* ?w.
  MINUS { [] nif:nextWord ?first }
  BIND(URI(concat(str(?first),"_sentence")) as ?s)
};

# note:
# - struct encoding can lead to duplications in the data if layers had to be inferred,
# - if the same property occurs multiple times, it will be assigned multiple values => aggregate values
# - in CoNLL, we loose structured annotation layers, so the same layer will be broken into many columns
#   (and if the same property occurs on different layers, a single column will conflate information from
#   different layers)
# - in CoNLL, we loose all metadata
